Just a copy-paste of the previous logic

// ==== Package ==== :
package Model.model.dynamics.accelerators;

// ==== General ==== :
import java.awt.Point;

import Engine.api.components.ContinuumIntegration;
import Math.Vector;



/* Time is in nano-seconds, points must be arranged from first to last.
 * They were planned to make use of Bernstein pols, but another day... ig
 */
public class Trajectory implements ContinuumIntegration{

    // ==== Fields ==== :

    // Instances:
    private Point[] points; /* Path generation */
    public Vector position; /* Anchorable-functionality field */
    
    private long internalTime, duration, offset; /* LoopIntegration fields */
    private boolean updated = false;

    

    // ==== Interfaces ==== : ( Find documentation here: World > api )

    // LoopIntegration:
    @Override
    public void checkIn( long time ){
        if( !this.updated ){
            this.updated = true;
            
            this.internalTime = time;
            this.position.set( this.getAt(this.internalTime) );
        }
    }
    @Override
    public void checkOut( long time ){
        if( this.updated ){
            this.updated = false;
        }
    }



    // ==== Methods ==== :

    // Instances:
    public Vector getAt(long time) {

        double t = ((time + this.offset) % this.duration) / (double) this.duration;

        Point p0 = this.points[0];
        Point p1 = this.points[1];

        double x = p0.getX() + t * (p1.getX() - p0.getX());
        double y = p0.getY() + t * (p1.getY() - p0.getY());

        return new Vector(x, y);
    }

    public void tweakDuration( double durationSecs ){
        this.duration = (long) (durationSecs*Math.pow(10, 9));
    }


    // ==== Constructors ==== :


    public Trajectory( Point point1, Point point2, double[] limits ){
        /* duration & offsegt are given in secs */
        this.duration = (long) (((limits[ Obstacle.DEAFULT_UP_DURATION_LIMIT ] - limits[ Obstacle.DEAFULT_LOW_DURATION_LIMIT ]) * Math.random() + limits[ Obstacle.DEAFULT_LOW_DURATION_LIMIT ])*Math.pow(10, 9));

        this.offset = (long) ( limits[ Obstacle.DEAFULT_UP_DURATION_LIMIT ]*Math.random()*Math.pow(10, 9));
        this.internalTime = System.nanoTime();

        this.points = new Point[2];
        this.points[0] = point1;
        this.points[1] = point2;

        double t = ((internalTime + this.offset) % this.duration) / (double) this.duration;

        double x = this.points[0].getX() + t * (this.points[1].getX() - this.points[0].getX());
        double y = this.points[1].getY() + t * (this.points[1].getY() - this.points[0].getY());

        // Initial setting:
        this.position = new Vector( x, y );
    }
}